<script>
  var points = 0;
</script>
<section>
  <p id="skip">
    <a href="#meat-and-potatoes">Click here to skip to the meat-and-potatoes</a
    >. Otherwise you <em>will</em> end up reading a story about why I wrote this
    article. It reads like a preface to an online recipe and
    <abbr title="Your milage may vary">ymmv</abbr>.
    <a href="#meat-and-potatoes"
      >Last chance, click here NOW to go to the good shit</a
    >.
  </p>
  <p id="bait">
    ... ok now that the nerds are gone ... this one is for all the online
    recipes fans out there ...
    <a id="click-bait" href="#">click here to reveal a bonus preface ...</a>
  </p>
  <dialog id="scoreboard"></dialog>
  <p id="psych" class="hide">
    <a href="#">oof, got'ya ... ok for real now, let's skip ahead ...</a>
  </p>
  <script>
    (() => {
      function baitAndSwitch() {
        points += 1;
        const scoreboard = document.getElementById("scoreboard");
        if (scoreboard) {
          scoreboard.innerHTML = `ðŸ‘Œ psych, harley ${points} - you 0`;
          if (scoreboard.showModal) {
            scoreboard.showModal();
          } else {
            scoreboard.setAttribute("open", true);
          }
        }
        const skip = document.getElementById("skip");
        const bait = document.getElementById("bait");
        const psych = document.getElementById("psych");
        if (skip) skip.classList.add("hide");
        if (bait) bait.classList.add("hide");
        if (psych) psych.classList.remove("hide");
      }
      function initialise() {
        const clickBait = document.getElementById("click-bait");
        clickBait.addEventListener("click", baitAndSwitch, false);
        const psych = document.getElementById("psych");
        psych.addEventListener("click", baitAndSwitch, false);
        const scoreboard = document.getElementById("scoreboard");
        scoreboard.addEventListener("click", function () {
          if (scoreboard.close) {
            scoreboard.close();
          } else {
            scoreboard.removeAttribute("open");
          }
        });
      }
      window.addEventListener("load", initialise, false);
    })();
  </script>
  <hr />
  <p class="extra">
    Writing can be as tedious as publishing, but the pain of publishing can be
    turned into a quick and easy experience with the help of the right software.
    Sites like Blogger and Medium, as well as products like Wordpress are among
    the easiest and most popular solutions for blogging. In my case, I wanted to
    make my own solution because damn it, I'm a web developer and this is my
    website.
    <u
      ><em
        >How hard can it really be to write software to publish blog posts?</em
      ></u
    >
  </p>
  <p>
    So I took a stab at writing my own solution, that's what I'll describe here
    in this blog post. I sought out to create a solution that matched a few
    criteria that I imagined would be my ideal self-publication experience. In
    particular, I needed my custom blogging software to give me the ability to:
  </p>
  <ul>
    <li>write blog posts in plain HTML, nothing fancy like markdown,</li>
    <li>save my blog posts to files, avoiding the need for databases,</li>
    <li>easily integrate into my current site styles, for consistency,</li>
    <li>avoid javascript frameworks, to keep my site light and quick,</li>
    <li>create the system myself, for the sake of fun.</li>
  </ul>
  <p>I realized I needed static site generation.</p>
</section>
<section>
  <h2>Static Site Generation (SSG)</h2>
  <p>
    What the <em>he||</em> is SSG and why would we use it? Cloudflare
    <a
      href="https://www.cloudflare.com/learning/performance/static-site-generator/"
      >defines SSG as </a
    >...
  </p>
  <blockquote>
    ... a tool that generates a full static HTML website based on raw data and a
    set of templates. Essentially, a static site generator automates the task of
    coding individual HTML pages and gets those pages ready to serve to users
    ahead of time. Because these HTML pages are pre-built, they can load very
    quickly in users' browsers.
  </blockquote>
  <p>
    So SSG is a tool that generates static files and because those files are
    static, pages load quickly. But what exactly do SSG tools do to
    generate those static files, and when does this process happen? FreeCodeCamp
    <a
      href="https://www.freecodecamp.org/news/static-site-generation-with-nextjs/"
      >describes SSG as a process of</a
    >
    ...
  </p>
  <blockquote class="margin-tb-20">
    ... compiling and rendering a website or app at build time. The output is a
    bunch of static files, including the HTML file itself and assets like
    JavaScript and CSS.
  </blockquote>
  <p>
    The same FreeCodeCamp article above mentions
    <a href="https://nextjs.org/">Next.js</a> as an option for applications
    built in React, which would give me excellent control and out-of-the-box
    config for performing SSG.
  </p>
  <details>
    <summary>
      Unfortunately Next.js is not a good option for me simply because my
      personal website does not use React. I briefly unpacked this tangent,
      click here to read more.
    </summary>
    <p class="margin-left-20">
      This probably deserves a blog post in-and-of-itself, but for illustration,
      most interactivity on my site is either written in typescript and compiled
      down to a javascript module (e.g., see my
      <a
        href="https://github.com/harleylang/harleys-website/blob/main/www/js/modules/show-html-comments/src/index.ts"
        >show-html-comments</a
      >
      module; it's responsible for
      <a href="../index.html">the HTML comment easter egg on my about page</a>),
      or a small web component (e.g., see my
      <a
        href="https://github.com/harleylang/harleys-website/blob/main/www/js/components/me-carousel/src/index.ts"
        >poloroid-like carousel</a
      >). (And because I wanted my blog posts to be written in HTML, I could
      even write one-off javascript interactivity, like the "cooking recipe"
      easter egg functionality at the beginning of this post.)
    </p>
    <p class="margin-left-20">
      I just haven't written interactivity that requires stateful layers or
      super complex user experiences to justify reaching for javascript
      frameworks (yet). Instead, my use cases are small and discrete, which can
      be perfectly addressed by importing small and discrete global javascript
      modules.
    </p>
    <p class="margin-left-20">
      This allows me to easily add-and-remove scripts to different pages, as
      well as gain a performance boost because each script is bundled and loaded
      separately. So although I am a big fan of React, for now I'd prefer an
      option that will keep my javascript overhead light.
    </p>
  </details>
  <p>
    Anyways, I'm in the mood to build an SSG tool myself with vanilla javascript
    and node. So let's begin.
  </p>
</section>
<section>
  <h2 id="meat-and-potatoes">My Solution</h2>
  <p>
    Currently my personal website follows a simple folder structure that is
    traditionally used in server directories, which is recommended in the
    <a
      href="https://modern-web.dev/guides/going-buildless/serving/#serving-web-content"
      >modern web dev</a
    >
    guide:
  </p>
  <pre><code>
  www
  â””â”€â”€ css
      â””â”€â”€  ... css assets in here
  â””â”€â”€ html
      â”œâ”€â”€ index.html
      â””â”€â”€ ... other html
  â””â”€â”€ js
      â””â”€â”€  ... js assets in here
</code></pre>
  <p>
    To get started, I updated my <code>package.json</code> with the following
    scripts that will trigger my custom SSG script in two situations:
  </p>
  <pre><code>
  "start": "yarn start:server & yarn start:scss & yarn start:ssg",
  "start:server": "wds --config ./wds.config.mjs --app-index www/html/index.html",
  "start:scss": "sass --no-source-map -w www/css --style compressed",
  "start:ssg": "yarn start:ssg:blog",
  "start:ssg:blog": "esr .bin/watch.mjs --dir www/html/blog --ignore index.html --cmd 'yarn build:ssg:blog'",
  "build": "rm -rf public && yarn build:ssg && yarn sass && rollup -c ./rollup.config.mjs",
  "build:ssg": "yarn build:ssg:blog",
  "build:ssg:blog": "esr .bin/ssg.mjs --template www/html/blog/template.html && prettier --write www/html/blog/**/index.html",
</code></pre>
  <p>A couple critical additions here:</p>
  <ol class="flex flex-column flex-gap-10">
    <li>
      <code>start</code> runs <code>start:ssg</code> and therefore runs
      <code>start:ssg:blog</code> in parallel with other local development
      config.
    </li>
    <ul>
      <li>
        Notice that <code>start:ssg:blog</code> calls
        <code>.bin/watch.mjs</code>.
      </li>
      <li>
        Also notice that <code>yarn build:ssg:blog</code> is passed as the
        "--cmd" argument to the <code>.bin/watch.mjs</code> script.
      </li>
    </ul>
    <li>
      <code>build</code> runs <code>build:ssg</code> and therefore runs
      <code>build:ssg:blog</code>.
    </li>
    <ul>
      <li>
        Notice that <code>build:ssg:blog</code> calls <code>.bin/ssg.mjg</code>.
      </li>
    </ul>
  </ol>
  <p>
    <code>watch.mjs</code> is a handy script that will watch a directory for
    file changes and trigger a side-effect command in response. In this case,
    the command <code>yarn build:ssg:blog</code> runs in response to file
    changes. Essentially this provides hot-module-reloading in my local
    development environment for all SSG'd content. This means that I can make
    changes to a blog file, save it, and immediately see the SSG'd version of
    that blog post in my browser. Much of the heavy lifting for this
    functionality is provided by the
    <a href="https://github.com/paulmillr/chokidar">chokidar</a> node library,
    meaning
    <a
      href="https://github.com/harleylang/harleys-website/blob/main/.bin/watch.mjs"
      >the source code for this watch script</a
    >
    is as little as 20 lines of node code. Not bad!
  </p>
  <p></p>
</section>
